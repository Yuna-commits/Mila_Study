Mila_Study
==========
* 성장률
  - 입력값의 크기에 따른 함수의 증가량
* 점근적 표기법
  - 중요하지 않은 상수와 계수들을 제거, 알고리즘의 실행 시간에서 중요한 성장률에 집중
> 1. 최상의 경우 : 오메가 표기법 (Big-Ω)
> 2. 평균의 경우 : 세타 표기법 (Big-θ)
> 3. 최악의 경우 : 빅오 표기법 (Big-O)
* __알고리즘이 최악일 때의 경우를 판단하면 평균과 가까운 성능으로 예측하기 쉽기 때문에 빅오를 사용__
---------------------------  
시간복잡도(Time complexity)  
===========
![image](https://github.com/user-attachments/assets/241a6ddd-0260-44c3-8f28-7fa97f254fac)
---------------------------
* 알고리즘을 수행하기 위해 프로세스가 수행해야하는 연산을 수치화한 것
* __가장 큰 영향을 미치는 n의 단위가 중요__
> 1 : O(1) -> 상수  
> 2n + 20 : O(n) -> n이 가장 큰 영향을 미침  
> 3n^2 : O(n^2) -> n^2이 가장 큰 영향을 미침

## 시간복잡도의 문제해결 단계
* O(1) : 상수시간 -> 문제를 해결하는데 오직 한 단계만 처리함  
  > 입력값 크기가 소요 시간에 영향을 주지 않음
  ```
  printf("hello, world!");
  ```
* O(n) : 선형 시간 -> 문제를 해결하기 위한 단계의 수와 입력값 n이 1 : 1 관계를 가짐
  > 입력이 증가하면 처리 시간 || 메모리 사용이 선형적으로 증가
  - Case 1
  ```
  for(int i = 0; i < n; i++)
  <pre><code>{code}</code></pre>printf("%d", i);
  ```
  > i == 0일 때부터 n - 1까지 총 n번 실행
  - Case 2
  ```
  for(int i = 0; i < n / 2; i++)
  <pre><code>{code}</code></pre>printf("%d", i);
  ```
  > 반복문이 n / 2번 실행되고 O(n/2)이지만 상수를 무시하여 O(n)으로 봄
* O(n^2) : 2차 시간 -> 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱
  > 반복문이 두 번 있는 경우(각 원소를 다른 모든 원소와 비교하는 경우)
  > e.g. 버블 정렬, 선택 정렬, 삽입 정렬
* O(log n) : 로그 시간 -> 문제를 해결하는데 필요한 단계들이 연산마다 __특정 요인에 의해 줄어듬__  
  > 실행시간이 입력값 크기의 로그에 비례  
  - Case 1
  ```
  int i = 1;
  while(i < n){
    i = i * 2;
  }
  ```
  > n이 128이면 반복문은 i == 1일 때부터 2, 4, 8, 16, 32, 64까지 총 7번 실행  
  > log 128 == 7
  - Case 2
  ```
  int i = n;
  while(i > 1){
    i = i / 2;
  }
  ```
  > i == 128일 때부터 64, 32, 16, 8, 4, 2까지 총 7번 실행  
